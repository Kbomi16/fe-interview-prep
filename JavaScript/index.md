### ✅ 프로그래밍이란 뭐라고 생각하나요?

프로그래밍은 컴퓨터가 특정 작업을 수행할 수 있도록 명령어를 작성하는 과정. 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 상세하게 요구를 설명하는 작업이며, 그 결과물이 바로 코드다.

### ✅ 컴파일러는 뭐고 인터프리터는 뭔가요?

- **컴파일러**는 소스 코드를 한꺼번에 기계어로 변환한 후 실행하는 프로그램입니다. 실행 속도가 빠릅니다.
- **인터프리터**는 코드를 한 줄씩 읽고 바로 실행하는 방식입니다. 실행 속도는 느리지만 디버깅이 쉽습니다.
  > compile:변환하다
  > interpret:해석하다

### ✅ 자바스크립트란 뭐죠?

자바스크립트는 웹 브라우저에서 동작하는 동적 프로그래밍 언어로, 클라이언트 및 서버 측에서 모두 사용됩니다. 동적 타입, 비동기 처리, DOM 조작 등 다양한 기능을 제공합니다.

### ✅ 자바스크립트의 특징은 뭐가 있나요?

자바스크립트는 동적 타이핑을 사용하며, 프로토타입 기반 객체 지향 프로그래밍을 지원합니다. 또한, 이벤트 기반 비동기 처리가 가능하며, 브라우저에서 DOM을 조작할 수 있는 기능이 있습니다.

### ✅ 변수란 무엇인가요?

변수는 데이터를 저장할 수 있는 공간으로, 이름을 통해 값을 참조할 수 있습니다. 변수는 값을 저장하거나 재할당하여 사용할 수 있습니다. 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.

### ✅ 식별자란 무엇인가요?

식별자는 변수, 함수, 객체 등의 이름을 나타내는 용어입니다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다.

### ✅ 변수를 선언한다는 것은 어떤 것을 의미하나요?

변수를 선언한다는 것은 컴퓨터 메모리에 값을 저장할 공간을 예약하고, 해당 공간을 특정 이름(식별자)으로 부여하는 것을 의미합니다.

### ✅ var 키워드는 뭔가요?

`var`는 ES6 이전 자바스크립트에서 변수를 선언할 때 사용하는 키워드입니다. 함수 스코프를 따르며, 호이스팅이 발생하는 특징이 있습니다.

### ✅ 호이스팅이 뭔가요?

호이스팅은 자바스크립트에서 변수나 함수 선언이 코드 실행 전에 최상위로 끌어올려지는 현상입니다.
js 엔진은 변수 선언(을 포함한 모든 선언문)이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행한다. 런타임 이전에 실행 컨텍스트에 의해 소스코드 평가 과정에서 스코프에 등록되고 이를 마치 코드의 제일 위에 있는 것처럼 변수가 어디에 위치하던지와 상관없이 어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅이라고 합니다.

### ✅ var 키워드의 문제점은 무엇이 있나요?

1. 변수 중복 선언 허용
   var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되는데, 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.

2. 함수 레벨 스코프
   대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프라 한다.

3. 변수 호이스팅
   var 키워드로 선언된 변수는 선언과 동시에 undefined로 초기화되며, 런타임 즉 소스코드 평가 단계에서 스코프에 등록되기 때문에 실행 단계에서 실제 값이 할당되지 않더라도 undefined를 가지고있다. 이를 변수 호이스팅이라 한다.

### ✅ let 키워드는 var 키워드와 어떤 점이 다른가요?

`let`은 블록 스코프를 따르며, 호이스팅이 발생하지만 변수 선언 전에 참조하면 `ReferenceError`가 발생합니다. 이로 인해 `var`보다 더 안전하게 변수를 사용할 수 있습니다.

1. 변수 중복 선언 금지
   var 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러가 발생하지 않는다. 이때 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 재할당되어 변경되는 부작용이 발생한다. 하지만 let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생한다.

2. 블록 레벨 스코프
   let 키워드를 통해 선언된 변수는 블록 레벨 스코프를 따른다. 함수 뿐만 아니라 모든 코드 블록 내에 선언된 변수(지역 변수)는 해당 유효 범위(스코프)를 벗어나면 사용할 수 없다.

3. 변수 호이스팅
   var 키워드로 선언한 변수와 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

var 키워드였다면 변수 호이스팅에 의해 런타임 이전에 변수가 선언되어 undefined를 출력해야 한다. 하지만 let 키워드에서는 참조에러가 나타난다.

let 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러가 발생한다.

let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(TDZ: Temporal Dead Zone) 라 부른다.

4. 전역 객체와 let
   let 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다.

```js
let x = 1

// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.
console.log(window.x) // undefined
console.log(x) // 1
```

### ✅ TDZ란 무엇인가요?

TDZ(Temporal Dead Zone, 임시 사각 지대)는 `let`이나 `const`로 선언된 변수가 선언되기 전까지 참조할 수 없는 영역을 의미합니다. 변수 선언 전에 해당 변수를 참조하면 에러가 발생합니다.

### ✅ const 키워드는 어떤 특징이 있나요?

`const`는 상수(constant)를 선언할 때 사용하며, 선언과 동시에 값을 할당해야 하고, 이후 재할당이 불가능합니다. 그러나 객체나 배열의 경우 내부 값은 변경할 수 있습니다.

1. 선언과 초기화
   const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다. 그렇지 않을 경우 문법 에러(SyntaxError)가 발생한다.

2. 재할당 금지
   var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.

3. 상수
   const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없다. 원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 있는 방법이 없기 때문이다. 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 한다.

### 💡변수 선언 및 초기화 단계

| 키워드  | 선언 및 초기화 단계    | 선언 단계              | 선언 + 초기화 + 할당 | 할당 단계   | 초기화 단계 |
| ------- | ---------------------- | ---------------------- | -------------------- | ----------- | ----------- |
| `var`   | 정의됨 (값: undefined) | 정의됨 (값: undefined) | 정의됨 (값: 초기값)  | 값이 할당됨 | 값이 정의됨 |
| `let`   | 정의됨 (값: undefined) | 정의됨 (값: undefined) | 정의됨 (값: 초기값)  | 값이 할당됨 | 값이 정의됨 |
| `const` | 정의됨 (값: 초기값)    | 정의됨 (값: 초기값)    | 정의됨 (값: 초기값)  | 값이 할당됨 | 값이 정의됨 |

- **선언 단계**: 변수가 메모리에 생성되지만 값은 할당되지 않음.
- **초기화 단계**: 변수가 처음으로 값이 할당되는 단계.
- **할당 단계**: 이미 선언된 변수에 새로운 값을 할당하는 단계.

### ✅ 식별자 네이밍 규칙은 어떤 것들이 있나요?

식별자는 숫자로 시작할 수 없고, 대소문자를 구분하며, 예약어는 사용할 수 없습니다. 또한, 특수 문자는 `$`와 `_`만 허용됩니다.

### ✅ 네이밍 컨벤션은 어떤 것들이 있나요?

주로 사용되는 네이밍 컨벤션에는 `camelCase`(자바스크립트 변수 및 함수명), `PascalCase`(클래스명), `snake_case`(파이썬 변수명) 등이 있습니다.

### ✅ 리터럴이 뭔가요?

리터럴은 코드에서 고정된 값 자체를 의미합니다. 예를 들어 숫자 리터럴 `5`, 문자열 리터럴 `"Hello"` 등이 있습니다.

리터럴(literal)은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법(=notation) 을 말합니다.

### ✅ 데이터 타입의 종류는 어떤 것들이 있나요?

자바스크립트의 데이터 타입에는 원시 타입(숫자, 문자열, 불리언, undefined, null, 심벌)과 참조 타입(객체, 배열, 함수)이 있습니다.

### 💡데이터 타입

| 구분      | 데이터 타입           | 설명                                                |
| --------- | --------------------- | --------------------------------------------------- |
| 원시 타입 | 숫자 (number) 타입    | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
| 원시 타입 | 문자열 (string) 타입  | 문자열                                              |
| 원시 타입 | 불리언 (boolean) 타입 | 논리적 참 (true)과 거짓 (false)                     |
| 원시 타입 | undefined 타입        | `var` 키워드로 선언된 변수에 암묵적으로 할당되는 값 |
| 원시 타입 | null 타입             | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값   |
| 원시 타입 | 심벌 (symbol) 타입    | ES6에서 추가된 7번째 타입                           |
| 원시 타입 | BigInt 타입           | 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형  |
| 객체 타입 |                       | 객체, 함수, 배열 등                                 |

### ✅ 심벌 타입은 뭐죠?

심벌(Symbol)은 ES6에서 도입된 원시 타입 중 하나로, 유일하고 변경 불가능한 값을 나타냅니다. 객체의 고유한 프로퍼티 키를 정의할 때 주로 사용됩니다.

### ✅ 데이터 타입은 왜 필요할까요?

1. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
2. 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해

### ✅ 정적 타이핑이 뭔가요?

정적 타이핑은 컴파일 시에 변수의 데이터 타입이 고정되는 방식을 의미합니다. 이를 통해 타입 안전성을 보장하고, 오류를 사전에 방지할 수 있습니다.

- 대표적인 정적 타입 언어로 C, C++, 자바, 코틀린, 고, 러스트 등

### ✅ 동적 타이핑이 뭔가요?

동적 타이핑은 실행 중에 변수의 데이터 타입이 결정되는 방식입니다. 자바스크립트는 동적 타이핑을 지원하며, 같은 변수에 다른 타입의 값을 저장할 수 있습니다.

- 대표적인 동적 타입 언어로는 자바스크립트, 파이썬, PHP 등

### ✅ 명시적 타입 변환이 뭔가요?

명시적 타입 변환은 프로그래머가 의도적으로 한 타입의 값을 다른 타입으로 변환하는 것을 의미합니다. 예를 들어 `Number('123')`은 문자열을 숫자로 변환합니다.

### ✅ 명시적 타입 변환 함수를 예를 들어볼 수 있나요?

- `Number()` : 문자열을 숫자로 변환
- `String()` : 숫자나 불리언 값을 문자열로 변환
- `Boolean()` : 값이 truthy인지 falsy인지에 따라 불리언 값으로 변환

💡문자열이 아닌 값을 문자열 타입으로 변환하는 방법

```js
// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
String(1) // -> "1"

// 2. Object.prototype.toString 메서드를 사용하는 방법
;(1).toString() // -> "1"

// 3. 문자열 연결 연산자를 이용하는 방법
1 + '' // -> "1"
```

💡숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법

```js
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
Number('0') // -> 0

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)
parseInt('0') // -> 0

// 3. + 단항 산술 연산자를 이용하는 방법
;+'0' // -> 0

// 4. * 산술 연산자를 이용하는 방법
'0' * 1 // -> 0
```

💡불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

```js
// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 불리언 타입
Boolean('x') // -> true
Boolean('') // -> false
Boolean('false') // -> true
// 숫자 타입 => 불리언 타입
Boolean(0) // -> false
Boolean(1) // -> true
Boolean(NaN) // -> false
Boolean(Infinity) // -> true
// null 타입 => 불리언 타입
Boolean(null) // -> false
// undefined 타입 => 불리언 타입
Boolean(undefined) // -> false
// 객체 타입 => 불리언 타입
Boolean({}) // -> true
Boolean([]) // -> true

// 2. ! 부정 논리 연산자를 두번 사용하는 방법
// 문자열 타입 => 불리언 타입
!!'x' // -> true
!!'' // -> false
!!'false' // -> true
// 숫자 타입 => 불리언 타입
!!0 // -> false
!!1 // -> true
!!NaN // -> false
!!Infinity // -> true
// null 타입 => 불리언 타입
!!null // -> false
// undefined 타입 => 불리언 타입
!!undefined // -> false
// 객체 타입 => 불리언 타입
!!{} // -> true
!![] // -> true
```

### ✅ 암묵적 타입 변환이 뭔가요?

암묵적 타입 변환은 자바스크립트 엔진이 자동으로 타입을 변환하는 과정입니다. 예를 들어, 숫자와 문자열의 덧셈 연산에서 자바스크립트는 숫자를 문자열로 자동 변환합니다.

### ✅ truthy / falsy 한 값이 뭔가요?

자바스크립트에서 조건문 등에서 참으로 평가되는 값을 **truthy**, 거짓으로 평가되는 값을 **falsy**라고 합니다. falsy 값에는 `0`, `null`, `undefined`, `NaN`, `''`, `false`가 있습니다.

### ✅ 자바스크립트의 배열은 자료구조의 배열과 같나요?

자바스크립트의 배열은 동적 크기를 가지며, 배열의 요소가 연속된 메모리 공간에 저장되지 않을 수 있습니다. 자료구조의 배열과 달리 다양한 타입의 데이터를 함께 저장할 수 있습니다.

### ✅ 배열의 메서드는 어떤 종류가 있나요?

자바스크립트 배열 메서드에는 `push()`, `pop()`, `shift()`, `unshift()`, `map()`, `filter()`, `forEach()`, `reduce()` 등이 있습니다.

### ✅ 고차 함수에 대해서 아나요?

고차 함수(Higher-Order Function)는 함수를 인자로 받거나, 함수를 반환하는 함수를 의미합니다. 자바스크립트의 `map()`, `filter()`, `reduce()`가 대표적인 고차 함수입니다.

### ✅ forEach 메서드와 map 메서드의 차이점에 대해 알고 있나요?

- `forEach()`는 배열의 각 요소에 대해 반복 실행할 뿐, 새로운 배열을 반환하지 않습니다.
- `map()`은 배열의 각 요소를 변환한 결과로 새로운 배열을 반환합니다.

### ✅ 자바스크립트에서 객체란 뭘까요?

자바스크립트에서 객체는 여러 개의 속성(프로퍼티)와 메서드를 포함하는 데이터 구조입니다. 키-값 쌍으로 이루어져 있으며, 복잡한 데이터를 저장하고 관리할 수 있는 형태입니다.

### ✅ 함수와 메서드의 차이점에 대해 알고 계신가요?

함수는 독립적으로 정의되고 호출되는 코드 블록입니다. 메서드는 객체의 프로퍼티로 포함된 함수이며, 객체 내에서 동작을 수행하는 데 사용됩니다.

메서드는 객체에 묶여 있는 함수를 의미한다.

```js
var person = {
  name: "Lee",
  age: 20,
  hello: function () {
    console.log("hello :" + this.name);
  },
};

console.log(person);
>>>
{ name: 'Lee', age: 20, hello: [Function: hello] }
```

### ✅ 자바스크립트에서 객체를 생성하는 방법은 어떤 것들이 있나요?

- **객체 리터럴**로 생성: `{}`를 사용해 객체를 정의합니다.
- **생성자 함수**로 생성: `new` 키워드를 사용해 함수로부터 객체를 생성합니다.
- **Object.create()**를 사용해 생성: 다른 객체를 프로토타입으로 하는 새 객체를 생성합니다.

### ✅ 전역 객체에 대해서 아나요?

- 전역 객체는 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체다.
- 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다.
- 전역 객체는 표준 빌트인 객체(Object, String, Number, Function, Array...) 들과 환경에 따른 호스트 객체, 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

### ✅ 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유가 있을까요?

자바스크립트에서 데이터 타입을 원시 타입(Primitive)과 객체(Reference)로 나누는 이유는 값의 저장 방식과 메모리 참조 방식이 다르기 때문입니다. 원시 값은 고정된 크기를 가지는 데이터이며, 객체는 크기가 변할 수 있는 복잡한 데이터를 다룹니다.

### ✅ 값에 의한 전달이 뭔가요?

값에 의한 전달은 원시 타입의 데이터를 함수에 전달할 때, 변수에 저장된 값을 복사하여 전달하는 방식입니다. 전달된 값이 변경되더라도 원본 데이터는 영향을 받지 않습니다.

```js
var score = 80

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score

console.log(score, copy) // 80  80
console.log(score === copy) // true

// score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.
score = 100

console.log(score, copy) // 100  80
console.log(score === copy) // false
```

### ✅ 참조에 의한 전달이 뭔가요?

참조에 의한 전달은 객체 타입의 데이터를 함수에 전달할 때, 변수에 저장된 참조(메모리 주소)를 전달하는 방식입니다. 전달된 객체를 변경하면 원본 객체에도 영향을 미칩니다.

객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. 이를 '참조에 의한 전달' 이라 한다.

```js
var person = {
  name: 'Lee',
}

// 참조값을 복사(얕은 복사)
var copy = person
```

### ✅ 자바스크립트에서 함수를 정의하는 방법은 몇 가지가 있나요?

자바스크립트에서 함수를 정의하는 방법은 주로 세 가지입니다:

- **함수 선언문**: `function` 키워드로 함수를 정의합니다.
- **함수 표현식**: 변수를 사용하여 함수를 정의합니다.
- **화살표 함수**: `=>` 문법을 사용하여 간결하게 함수를 정의합니다.

```js
case 1 :함수 선언문

function add(x,y){
  return x+y;
}

case 2: 함수 표현식
var add = function(x,y){
  return x + y;
}

case 3: Function 생성자 함수
var add = new Function('x','y', 'return x+y');

case 4: 화살표 함수(ES6)
var add = (x,y) => x+y;
```

### ✅ 함수 선언문과 함수 표현식은 어떤 차이가 있나요?

- **함수 선언문**은 호이스팅되어 함수 선언 이전에 호출할 수 있습니다.
- **함수 표현식**은 변수에 할당된 함수로, 선언 이후에만 호출할 수 있습니다.

```js
// 함수 참조
console.dir(add) // ƒ add(x, y)
console.dir(sub) // undefined

// 함수 호출
console.log(add(2, 5))
// 7 why? 함수 선언문은 표현식이 아닌 문으로, 런타임 이전에 js 엔진에 의해 실행된다.

console.log(sub(2, 5))
// TypeError: sub is not a function, why? 함수 표현식(표현식인 문)은 런타임에 값을 할당하기 때문에 sub는 현재 undefined로만 초기화된 상태이다.

// ① 함수 선언문
function add(x, y) {
  return x + y
}

// ② 함수 표현식
var sub = function (x, y) {
  return x - y
}
```

### ✅ 즉시 실행 함수(IIFE)에 대해 알고 있나요? 알고 있다면 아는 내용에 대해 말해보세요.

IIFE(Immediately Invoked Function Expression)는 정의된 즉시 실행되는 함수입니다. 주로 스코프를 격리하여 전역 변수를 오염시키지 않기 위해 사용됩니다.

```js
;(function () {
  console.log('즉시 실행')
})()
```

### ✅ 스코프가 뭔가요?

스코프는 변수가 참조될 수 있는 범위를 의미합니다. 스코프에 따라 변수가 어디에서 유효하고 접근 가능한지가 결정됩니다.

### ✅ 스코프에는 어떤 종류가 있죠?

자바스크립트에는 주로 두 가지 스코프가 있습니다:

- 전역 스코프: 코드 전체에서 접근할 수 있는 범위
- 지역 스코프: 특정 코드 블록이나 함수 내에서만 접근 가능한 범위

### ✅ 렉시컬 스코프를 아나요? 안다면 렉시컬 스코프는 무엇을 의미하나요?

렉시컬 스코프는 함수가 선언된 위치에 따라 상위 스코프가 결정되는 스코프 규칙입니다. 자바스크립트에서는 함수가 어디에서 호출되었는지가 아니라, 어디에서 정의되었는지에 따라 스코프가 결정됩니다.

```js
function outer() {
  let outerVar = 'I am from outer'

  function inner() {
    let innerVar = 'I am from inner'
    console.log(outerVar) // 접근 가능
    console.log(innerVar) // 접근 가능
  }

  inner()
  console.log(outerVar) // 접근 가능
  // console.log(innerVar); // 접근 불가, ReferenceError 발생
}

outer()
```

### ✅ 전역 변수로 변수를 선언하면 생기는 문제점은 무엇이 있을까요?

전역 변수는 어디에서나 접근할 수 있기 때문에, 여러 코드 블록에서 의도치 않게 값이 변경될 수 있습니다. 전역 변수의 남용은 네임스페이스 오염과 같은 문제를 야기합니다.

1. 암묵적 결합
   전역 변수를 선언한 의도는 전역, 즉 코드 어디서든 참조하고 할당할 수 있는 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용하는 것이다. 변수의 유효 범위(스코프)가 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

2. 변수의 긴 생명주기
   전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다. 또한 전역 변수의 상태를 변경할 수 있는 시간도 길고 기회도 많다. 변수 이름이 중복되기라도 한다면 의도치 않은 재할당이 이뤄지기도 한다.

3. 스코프 체인 상에서 종점에 존재
   전역 변수는 스코프 체인 상에서 종점에 존재한다. 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 말한다. 즉, 전역 변수의 검색 속도가 가장 느리다. 검색 속도의 차이는 그다지 크지 않지만 속도의 차이는 분명히 있다.

4. 네임스페이스 오염
   자바스크립트의 가장 큰 문제점 중 하나는 파일이 분리되어 있다 해도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.

### ✅ 생성자 함수가 뭔가요?

생성자 함수는 new 키워드를 사용해 객체(인스턴스)를 생성하는 함수입니다. 객체의 초기 속성 값을 설정하는 역할을 합니다.

### ✅ 객체 리터럴로 만들 때와는 무슨 차이가 있죠? 왜 생성자 함수를 사용하나요?

객체 리터럴은 단순히 하나의 객체를 만드는 방법이지만, 생성자 함수는 여러 개의 객체를 쉽게 생성할 수 있게 해줍니다. 생성자 함수는 공통된 구조의 객체를 반복해서 생성하는 데 유용합니다.

### ✅ 생성자 함수가 객체(인스턴스)를 생성하는 과정에 대해 간략하게 설명해줄 수 있나요?

새로운 빈 객체가 생성됩니다.
생성자 함수 내부에서 this는 생성된 객체를 참조합니다.
생성자 함수의 프로퍼티와 메서드가 this에 할당됩니다.
생성된 객체가 반환됩니다.

### ✅ 일급 객체가 뭔가요?

일급 객체는 변수에 할당할 수 있고, 다른 함수의 인자로 전달되며, 함수의 반환값으로도 사용될 수 있는 객체입니다. 자바스크립트에서 함수는 일급 객체입니다.

### ✅ 자바스크립트에서 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?

함수를 변수에 저장할 수 있습니다.
함수를 다른 함수에 인자로 전달할 수 있습니다.
함수를 다른 함수의 반환값으로 사용할 수 있습니다.
함수 배열이나 객체에 포함할 수 있습니다.

### ✅ 꼬리 질문) 함수형 프로그래밍이 뭔가요?

함수형 프로그래밍은 상태 변화나 부작용을 최소화하며 순수 함수를 활용하는 프로그래밍 패러다임입니다. 함수형 프로그래밍에서는 데이터를 변경하지 않고, 데이터 흐름을 함수의 조합으로 처리합니다.

### ✅ 꼬리 질문) 순수 함수가 뭔가요? 일반 함수와는 어떤 차이가 있죠?

순수 함수는 동일한 인자를 받으면 항상 동일한 결과를 반환하며, 함수 외부의 상태를 변경하지 않는 함수입니다. 일반 함수는 외부 상태를 변경하거나 부작용이 있을 수 있지만, 순수 함수는 이를 피하여 예측 가능한 코드를 작성할 수 있게 합니다.

### ✅ Map과 Set 그리고 Lookup Table

- **Map**: 키-값 쌍을 저장하는 데이터 구조로, 키의 순서가 유지되며, 어떤 데이터 타입도 키로 사용할 수 있습니다.
- **Set**: 중복되지 않는 값을 저장하는 데이터 구조로, 순서가 유지되며, 유일한 값만 포함됩니다.
- **Lookup Table**: 주어진 키에 대해 빠른 검색을 제공하는 테이블로, 키와 값을 연관지어 데이터를 효율적으로 검색할 수 있습니다.

### ✅ 객체지향 프로그래밍은 무엇을 의미하나요?

객체지향 프로그래밍(OOP)은 데이터를 객체로 구성하고, 객체 간의 상호작용을 통해 프로그램을 설계하는 패러다임입니다. 이는 코드의 재사용성과 유지보수성을 높이는 데 도움을 줍니다.

### ✅ 객체지향 프로그래밍의 특징에 대해 말해볼 수 있나요?

1. 추상화 (Abstraciton)
   객체를 구성할 수 있는 다양한 속성(프로퍼티) 중에서 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 추상화라 한다.

2. 캡슐화 (Encapsulation)

- 데이터 구조와 데이터를 다루는 방법들을 목적에 따라 결합 시켜 묶는 것. 다시 한번 말하자면 변수와 함수를 하나로 묶는것을 말한다.
- 또한 데이터를 절대로 외부에서 직접 접근을 하면 안되고 오로지 함수를 통해서만 접근해야하는데 이를 가능하게 해주는 것이 바로 캡슐화이다.

3. 상속 (Inheritance)
   상위 개념의 특징을 하위 개념이 물려받는 것

4. 다형성 (Polymorphism)
   부모클레스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것

### ✅ 자바스크립트는 객체지향 프로그래밍 언어인가요?

자바스크립트는 프로토타입 기반의 객체지향 프로그래밍 언어로, 객체를 생성하고 상속하는 기능을 제공합니다. 그러나 전통적인 클래스 기반 OOP와는 차이가 있습니다.

클래스 기반 객체지향 프로그래밍 언어와 달리 프로토타입 기반의 객체지향 프로그래밍입니다.

### ✅ 프로토타입이 뭔가요?

프로토타입은 자바스크립트에서 객체가 다른 객체로부터 속성과 메서드를 상속받는 방식을 의미합니다. 모든 객체는 `[[Prototype]]` 속성을 가지고 있으며, 이를 통해 상속을 구현합니다.

### ✅ strict mode가 뭔가요?

Strict mode는 자바스크립트의 안전한 사용을 위해 특정 기능을 제한하는 모드입니다. 이를 통해 에러를 조기에 발견하고, 불완전한 코드 작성을 방지할 수 있습니다.

### ✅ strict mode를 통해 무엇을 예방할 수 있죠?

1. 암묵적 전역
2. 변수, 함수, 매개변수의 삭제
3. 매개변수 이름의 중복

### ✅ 빌트인 객체가 뭔가요?

빌트인 객체는 자바스크립트에서 기본적으로 제공하는 객체로, 다양한 기능과 메서드를 포함하고 있습니다. 이러한 객체는 코드에서 직접 생성할 필요 없이 사용할 수 있습니다.

### ✅ 빌트인 객체의 종류는 어떤 게 있죠?

주요 빌트인 객체에는 `Object`, `Array`, `Function`, `String`, `Number`, `Boolean`, `Date`, `RegExp`, `Error` 등이 있습니다.

### ✅ 래퍼 객체에 대해서 알고 있나요?

래퍼 객체는 원시 값을 객체 형태로 감싸는 객체입니다. 예를 들어, 문자열 리터럴을 사용할 때 자바스크립트는 이를 `String` 래퍼 객체로 변환하여 메서드를 사용할 수 있도록 합니다.

### ✅ this가 뭔가요?

`this`는 자바스크립트에서 현재 실행 중인 함수의 컨텍스트를 참조하는 키워드입니다. 이 값은 함수가 호출되는 방식에 따라 달라집니다.

### ✅ this 바인딩이란?

`this` 바인딩은 특정 함수가 호출될 때 `this`가 어떤 객체를 참조할지를 결정하는 과정을 의미합니다. 호출 방식에 따라 다르게 바인딩됩니다.

### ✅ this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다르나요?

`this`의 바인딩은 함수 호출 방식에 따라 결정됩니다. 일반 함수 호출에서는 전역 객체를, 메서드 호출에서는 해당 객체를, `call`, `apply`, `bind` 메서드 사용 시에는 지정된 객체를 참조합니다.

### 💡함수 호출 방식 및 `this` 바인딩

| 호출 방식                                                  | `this` 바인딩                          |
| ---------------------------------------------------------- | -------------------------------------- |
| 일반 함수 호출                                             | 전역 객체 (window / global)            |
| 콜백 함수 호출                                             | 전역 객체 (window / global)            |
| 내부 함수 호출                                             | 전역 객체 (window / global)            |
| 메서드 호출                                                | 메서드를 호출한 객체                   |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스 |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | 첫 번째 인수로 전달한 객체             |

### ✅ 실행 컨텍스트에 대해 말해보세요.

실행 컨텍스트는 자바스크립트 코드가 실행될 때 생성되는 환경을 나타내며, 변수, 함수 선언, `this` 값을 포함합니다. 각 함수 호출 시 새로운 실행 컨텍스트가 생성됩니다.

### ✅ 클로저에 대해서 아나요?

> 클로저는 자신이 선언될 당시의 환경을 기억하는 함수

클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 (실행 컨텍스트 스택에서 제거되어 pop되더라도) 렉시컬 환경에 남아 참조가 가능하다

클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합입니다. 클로저를 사용하면 함수 외부에서 해당 함수의 변수를 참조할 수 있습니다.

### ✅ 클로저를 사용하면 뭐가 좋죠?

클로저를 사용하면 변수의 은닉성이 향상되고, 데이터의 상태를 유지하거나 함수의 상태를 저장할 수 있습니다. 또한, 모듈 패턴을 구현할 때 유용합니다.

### ✅ 클로저를 어떻게 생성하나요?

클로저는 중첩 함수에서 외부 함수의 변수를 참조하는 방식으로 생성됩니다. 아래 예시와 같습니다.

```javascript
function outer() {
  let outerVariable = 'I am outside!'
  return function inner() {
    console.log(outerVariable)
  }
}
const closureFunction = outer()
closureFunction() // 'I am outside!' 출력
```

### ✅ 자바스크립트에서 클래스가 생기기 전에는 어떤 방식으로 객체지향 패턴을 구현했나요?

자바스크립트에서 클래스가 도입되기 전에는 생성자 함수와 프로토타입을 사용하여 객체지향 패턴을 구현했습니다. 생성자 함수를 통해 객체를 만들고, 프로토타입을 사용해 메서드를 추가했습니다.

### ✅ 그럼 생성자 함수와 클래스는 어떤 차이가 있나요?

생성자 함수는 function 키워드로 정의되고, new 키워드로 호출합니다.
클래스는 class 키워드로 정의되며, 더 명확한 문법과 상속을 지원합니다. 클래스는 기본적으로 프로토타입 기반으로 동작하지만, 더 직관적인 문법을 제공합니다.

### ✅ 클래스 정의

클래스는 class 키워드를 사용하여 정의합니다. 예:

```javascript
class Person {
  constructor(name) {
    this.name = name
  }
  greet() {
    console.log(`Hello, my name is ${this.name}`)
  }
}
```

### ✅ 클래스의 상속

클래스 상속은 extends 키워드를 사용하여 구현합니다. 자식 클래스는 부모 클래스의 속성과 메서드를 상속받습니다.

```js
class Employee extends Person {
  constructor(name, position) {
    super(name)
    this.position = position
  }
  describe() {
    console.log(`I am a ${this.position}`)
  }
}
```

### ✅ spread 문법이 뭔가요?

스프레드 문법은 배열이나 객체의 요소를 개별적으로 분해하여 다른 배열이나 객체에 복사할 수 있는 문법입니다. ...을 사용합니다.

### ✅ 어떤 상황에서 사용할 수 있죠?

- 배열을 복사하거나 병합할 때
- 함수에 인자를 배열 형태로 전달할 때
- 객체를 복사하거나 새로운 속성을 추가할 때

### ✅ 구조 분해 할당이 뭔가요?

구조 분해 할당은 배열이나 객체의 값을 개별 변수에 쉽게 할당하는 문법입니다. 이를 통해 코드의 가독성을 높이고, 간결하게 변수를 정의할 수 있습니다.

### ✅ 구조 분해 할당은 크게 어떤 종류가 있나요?

- 배열 구조 분해 할당: 배열의 요소를 변수에 할당합니다.
- 객체 구조 분해 할당: 객체의 프로퍼티 값을 변수에 할당합니다.

### ✅ 브라우저의 렌더링 과정에 대해 설명해보세요.

브라우저의 렌더링 과정은 다음과 같습니다:

1. DOM 트리 생성: HTML 문서에서 DOM(Document Object Model) 트리를 생성합니다.
2. CSSOM 트리 생성: CSS 파일을 파싱하여 CSSOM(CSS Object Model) 트리를 생성합니다.
3. 렌더 트리 생성: DOM과 CSSOM을 결합하여 렌더 트리를 만듭니다.
4. 레이아웃: 요소의 위치와 크기를 계산합니다.
5. 페인팅: 요소를 화면에 그립니다.

### ✅ 브라우저의 렌더링 과정에 자바스크립트는 어떻게 동작하나요?

자바스크립트는 DOM을 조작하거나 이벤트에 반응하여 렌더링 과정에 영향을 미칩니다. 스크립트가 실행되면 DOM이나 CSSOM을 수정하여 렌더 트리에 영향을 줄 수 있으며, 이로 인해 렌더링이 다시 발생할 수 있습니다.

### ✅ <script></script> 태그를 <body></body> 태그 밑에 둬야 하는 이유가 있을까요?

스크립트를 <body> 태그 아래에 두면 DOM이 모두 로드된 후에 스크립트가 실행되어, DOM을 안전하게 조작할 수 있습니다. 만약 <head> 태그에 두면, DOM이 완전히 로드되기 전에 스크립트가 실행되어 오류가 발생할 수 있습니다.

### ✅ DOM이 뭔가요?

DOM(문서 객체 모델)은 HTML이나 XML 문서를 객체 형태로 표현한 모델로, 프로그래밍 언어를 통해 문서의 구조, 스타일, 내용을 동적으로 조작할 수 있도록 합니다.

### ✅ DOM을 구성하는 건 뭐가 있나요?

DOM은 문서의 요소(노드), 속성, 텍스트 등을 객체로 표현하며, 주요 구성 요소는 다음과 같습니다:

- 요소 노드 (Element Node)
- 텍스트 노드 (Text Node)
- 속성 노드 (Attribute Node)
- 주석 노드 (Comment Node)

### ✅ 마우스 이벤트 타입에는 뭐가 있나요?

| 이벤트 타입 | 이벤트 발생 시점                                      |
| ----------- | ----------------------------------------------------- |
| click       | 마우스 버튼을 클릭했을 때                             |
| dbclick     | 마우스 버튼을 더블 클릭했을 때                        |
| mousedown   | 마우스 버튼을 누르고 있을 때                          |
| mouseup     | 누르고 있던 마우스 버튼을 뗄 때                       |
| mousemove   | 마우스 커서를 움직일 때                               |
| mouseenter  | 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 x) |
| mouseover   | 마우스 커서를 HTML 요소 안으로 이동했을 때 (버블링 o) |
| mouseleave  | 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링 x) |
| mouseout    | 마우스 커서를 HTML 요소 밖으로 이동했을 때 (버블링 o) |

### ✅ 클릭을 대체할 수 있는 이벤트가 있나요?

`touchstart`나 `touchend`와 같은 터치 이벤트가 클릭을 대체할 수 있습니다. 또한, `pointerdown`과 `pointerup` 이벤트도 사용 가능합니다.

### ✅ 그 외에 알고 있는 대표적인 이벤트가 있나요?

- 키보드 이벤트 (`keydown`, `keyup`)
- 폼 이벤트 (`submit`, `input`)
- 윈도우 이벤트 (`resize`, `scroll`)

### ✅ 이벤트 핸들러를 등록하는 방식에는 어떤 것들이 있나요?

- HTML 요소의 `onclick` 속성에 직접 지정
- `addEventListener` 메서드 사용
- jQuery와 같은 라이브러리를 사용하여 등록

### ✅ 이벤트 전파(propagation)에 대해서 알고 있나요?

이벤트 전파는 이벤트가 발생한 요소에서 상위 요소로 전달되는 과정을 말합니다. 이는 두 가지 단계로 나뉩니다:

- **버블링**: 이벤트가 자식 요소에서 부모 요소로 전파됩니다.
- **캡처링**: 부모 요소에서 자식 요소로 전파됩니다.

### ✅ 이벤트 위임(delegation)에 대해서 알고 있나요?

이벤트 위임은 상위 요소에 이벤트 핸들러를 등록하여 하위 요소의 이벤트를 처리하는 방법입니다. 이를 통해 성능을 개선하고 코드의 유지보수성을 높일 수 있습니다.

### ✅ e.preventDefault에 대해 알고 있나요?

`e.preventDefault()` 메서드는 기본 이벤트 동작을 방지하는 메서드입니다. 예를 들어, `<a>` 태그 클릭 시 링크 이동을 막거나, 폼 제출 시 페이지 리로딩을 방지할 수 있습니다.

### ✅ e.stopPropagation은 무엇인가요?

`e.stopPropagation()` 메서드는 이벤트 전파를 중단시키는 메서드입니다. 이를 통해 특정 요소의 이벤트가 부모 요소로 전파되는 것을 방지할 수 있습니다.

### ✅ 호출 스케쥴링이 무엇인가요?

호출 스케줄링은 특정 시간에 함수 호출을 예약하는 것을 의미합니다. 이를 통해 이벤트나 타이머의 처리 순서를 조정할 수 있습니다.

### ✅ 타이머 함수에는 어떤 것들이 있나요?

- `setTimeout()`: 지정된 시간 후에 함수를 실행합니다.
- `setInterval()`: 지정된 시간 간격으로 함수를 반복 실행합니다.
- `clearTimeout()`: `setTimeout`으로 설정한 타이머를 취소합니다.
- `clearInterval()`: `setInterval`로 설정한 타이머를 취소합니다.

### ✅ 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우에 할 수 있는 어떤 일을 통해 해결할 수 있나요?

- **디바운스**: 특정 시간이 지나기 전까지 이벤트를 발생시키지 않고, 일정 시간 동안 이벤트가 발생하지 않을 때만 실행합니다.
- **쓰로틀**: 일정 시간 간격으로 한 번만 이벤트를 발생시키도록 제한합니다.

### ✅ 디바운스에 대해서 알고 있나요?

디바운스는 연속적으로 발생하는 이벤트에 대해 마지막 이벤트가 발생한 후 일정 시간 동안 함수 호출을 지연시키는 기법입니다. 이를 통해 불필요한 호출을 방지할 수 있습니다.

### ✅ 쓰로틀에 대해서 알고 있나요?

쓰로틀은 일정 시간 간격으로 이벤트를 발생시키는 기법입니다. 예를 들어, 스크롤 이벤트를 처리할 때, 지정된 간격만큼 호출을 제한하여 성능을 개선합니다.

### ✅ 동기와 비동기의 차이점에 대해서 설명해줄 수 있나요?

- **동기**: 작업이 순차적으로 진행되며, 이전 작업이 완료될 때까지 다음 작업이 대기합니다.
- **비동기**: 작업이 독립적으로 진행되며, 이전 작업이 완료되지 않아도 다음 작업이 실행될 수 있습니다. 비동기는 보통 콜백, 프로미스, async/await를 통해 구현됩니다.

### ✅ 한줄 요약

동기는 작업이 순차적으로 진행되는 반면, 비동기는 작업이 동시에 진행될 수 있습니다.

### ✅ 이벤트 루프와 태스크 큐에 대해서 알고 있나요?

이벤트 루프는 비동기 프로그래밍의 핵심 구조로, 콜 스택과 태스크 큐를 관리합니다. 태스크 큐는 비동기 작업이 완료된 후 실행할 콜백을 대기시키는 큐입니다.

### ✅ 마이크로태스크 큐에 대해서 알고 있나요?

마이크로태스크 큐는 Promise의 후속 작업이나 `MutationObserver`와 같은 특정 비동기 작업의 콜백을 저장하는 큐입니다. 이 큐는 태스크 큐보다 우선적으로 실행됩니다.

### ✅ 태스크 큐와 마이크로태스크 큐 중 어떤 것이 먼저 실행되나요?

마이크로태스크 큐의 콜백이 태스크 큐의 콜백보다 우선적으로 실행됩니다. 즉, 콜 스택이 비어 있을 때 마이크로태스크 큐의 작업이 먼저 실행됩니다.

### ✅ Ajax가 뭔가요 어떤 것을 담당하고 있죠?

Ajax(Asynchronous JavaScript and XML)는 비동기적으로 서버와 데이터를 교환할 수 있게 해주는 기술로, 페이지를 새로 고치지 않고도 서버의 데이터를 요청하고 업데이트할 수 있습니다.

### ✅ Ajax를 사용하면 기존 방식과 어떤 차이가 있을까요?

Ajax를 사용하면 전체 페이지를 새로 고치지 않고도 부분적으로 업데이트할 수 있어 사용자 경험이 향상됩니다. 반면, 기존 방식은 페이지 리로드가 필요하여 불필요한 트래픽을 발생시킵니다.

### ✅ JSON이 뭔가요?

JSON(JavaScript Object Notation)은 데이터 교환 형식으로, 가독성이 높고 경량의 텍스트 형식입니다. 자바스크립트 객체를 표현하는 데 사용되며, 다른 언어에서도 쉽게 읽고 쓸 수 있습니다.

### ✅ JSON이 제공하는 정적 프로토타입 메서드에 대해 몇가지 말해볼 수 있나요?

- `JSON.stringify()`: 자바스크립트 객체를 JSON 문자열로 변환합니다.
- `JSON.parse()`: JSON 문자열을 자바스크립트 객체로 변환합니다.

### ✅ Ajax로 HTTP 요청을 보내기 위해서는 어떤 방법을 사용할 수 있나요?

- **XMLHttpRequest**: 전통적인 방식으로 HTTP 요청을 보냅니다.
- **Fetch API**: 더 간결하고 직관적인 문법을 제공하는 최신 방법입니다.

### ✅ XMLHttpRequest와 fetch 메서드의 차이는 무엇이라고 생각하시나요?

- **XMLHttpRequest**는 비동기 요청을 다루기 위해 복잡한 콜백 구조가 필요합니다. 반면, **Fetch API**는 프로미스를 사용하여 간결하게 비동기 처리를 지원하며, 더 현대적인 문법을 제공합니다.

### ✅ REST API가 뭔가요?

REST(Representational State Transfer) API는 웹 서비스 아키텍처 스타일로, HTTP 프로토콜을 기반으로 클라이언트와 서버 간의 상호작용을 정의합니다. 자원에 대한 CRUD(Create, Read, Update, Delete) 작업을 지원합니다.

### ✅ REST API의 구성은 어떤 것이 있나요?

REST API는 다음과 같은 요소로 구성됩니다:

- **리소스**: 클라이언트가 요청하는 데이터의 단위
- **URI**: 리소스에 대한 고유한 식별자
- **HTTP 메서드**: 리소스에 대한 작업을 정의하는 방법 (GET, POST, PUT, DELETE 등)

### ✅ REST API를 설계하는 데 중요한 것이 있을까요?

- 리소스의 명확한 정의와 URI 설계
- HTTP 메서드를 적절히 사용하는 것
- 응답 코드와 메시지를 일관되게 처리하는 것

### ✅ HTTP 요청 메서드에 대해서 아는대로 얘기해보세요

- **GET**: 서버에서 데이터를 요청합니다.
- **POST**: 서버에 데이터를 전송하여 새로운 리소스를 생성합니다.
- **PUT**: 서버의 기존 리소스를 업데이트합니다.
- **DELETE**: 서버의 리소스를 삭제합니다.

### ✅ HTTP 상태 코드를 아는대로 말해주세요

- **200 OK**: 요청이 성공적으로 처리되었습니다.
- **201 Created**: 리소스가 성공적으로 생성되었습니다.
- **204 No Content**: 요청은 성공했지만 반환할 데이터가 없습니다.
- **400 Bad Request**: 잘못된 요청입니다.
- **404 Not Found**: 요청한 리소스를 찾을 수 없습니다.
- **500 Internal Server Error**: 서버 내부에서 오류가 발생했습니다.

### ✅ 콜백이란 뭐라고 생각하나요?

콜백은 다른 함수의 인수로 전달되는 함수로, 특정 작업이 완료된 후 호출되는 함수를 의미합니다. 비동기 처리에서 주로 사용됩니다.

### ✅ 프로미스가 뭔가요?

프로미스는 비동기 작업의 완료 또는 실패를 나타내는 객체로, 나중에 처리될 값을 표현합니다. 상태는 `pending`, `fulfilled`, `rejected`로 나뉩니다.

```js
// case 1 : 콜백 HELL 🔥

get('/step1', (a) => {
  get(`/step2/${a}`, (b) => {
    get(`/step3/${b}`, (c) => {
      get(`/step4/${c}`, (d) => {
        console.log(d)
      })
    })
  })
})
```

### ✅ 프로미스 생성 방법

`new Promise((resolve, reject) => { /* 비동기 작업 */ })` 형태로 생성합니다.

### ✅ 프로미스의 상태를 나타내는 것은 어떤 것들이 있나요?

- **pending**: 대기 중
- **fulfilled**: 이행됨 (성공적으로 완료됨)
- **rejected**: 거부됨 (실패함)

  ![](https://velog.velcdn.com/images/bori_note/post/d62065e8-c8ba-4a6a-bed3-afb1e6b89e21/image.png)

| 프로미스의 상태 | 의미                                  | 상태 변경 조건                   |
| --------------- | ------------------------------------- | -------------------------------- |
| pending         | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 |
| fulfilled       | 비동기 처리가 수행된 상태 (성공)      | `resolve` 함수 호출              |
| reject          | 비동기 처리가 수행된 상태 (실패)      | `reject` 함수 호출               |

### ✅ 프로미스 빌트인 객체가 제공하는 정적 메서드에 대해 알고 있나요?

- `Promise.all()`: 여러 프로미스를 배열로 받아 모두 이행되기를 기다립니다.
- `Promise.race()`: 여러 프로미스 중 가장 먼저 이행된 프로미스를 반환합니다.
- `Promise.resolve()`: 주어진 값으로 즉시 이행된 프로미스를 반환합니다.
- `Promise.reject()`: 주어진 이유로 즉시 거부된 프로미스를 반환합니다.

### ✅ 제너레이터란 뭔가요? 일반 함수와는 어떤 차이가 있죠?

제너레이터는 `function*` 문법을 사용하여 정의되는 함수로, 실행을 일시 중지하고 나중에 재개할 수 있는 특별한 함수입니다. 일반 함수는 호출 시 즉시 실행되고 반환되는 반면, 제너레이터는 `yield` 키워드를 통해 값을 반환하면서 상태를 유지합니다.

### ✅ 제너레이터의 구조

ES6에서 도입된 제너레이터(generator)는 코드 블록의 실행을 일시 중지 (블로킹) 했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

```js
// 제너레이터 함수
function* genFunc() {
  yield 1
  yield 2
  yield 3
}

// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
// 이터러블이면서 동시에 이터레이터인 제너레이터 객체는 next 메서드를 갖는다.
const generator = genFunc()

console.log(generator.next()) // {value: 1, done: false}

console.log(generator.next()) // {value: 2, done: false}

console.log(generator.next()) // {value: 3, done: false}

console.log(generator.next()) // {value: undefined, done: true}
```

### ✅ async/await가 뭔가요? 기존의 Promise와는 어떤 차이가 있죠?

async/await는 프로미스 기반의 비동기 코드를 동기적으로 작성할 수 있게 해주는 문법입니다. async 키워드는 함수가 항상 프로미스를 반환하도록 하고, await 키워드는 프로미스가 해결될 때까지 기다립니다. 기존 프로미스 체이닝보다 더 읽기 쉽고 직관적입니다.

### ✅ Promise와 async/await의 차이점 한 줄 요약

Promise는 비동기 작업의 결과를 처리하는 객체이고, async/await는 이를 보다 간결하고 동기적으로 작성할 수 있는 문법입니다.

### ✅ 에러처리를 왜 해야 하나요?

에러 처리는 프로그램의 안정성을 높이고, 예기치 않은 상황에서 사용자에게 적절한 피드백을 제공하기 위해 필요합니다.

### ✅ 자바스크립트에서 에러를 처리하는 방법에는 뭐가 있을까요?

- try...catch 문을 사용하여 동기 코드에서 발생하는 예외를 처리합니다.
- 프로미스의 catch() 메서드를 사용하여 비동기 작업에서 발생하는 오류를 처리합니다.
- window.onerror와 같은 전역 에러 핸들러를 설정합니다.

### ✅ 모듈이 뭔가요?

모듈은 독립적으로 재사용 가능한 코드의 블록으로, 관련된 함수, 객체, 변수를 그룹화하여 관리할 수 있게 해줍니다. ES6부터는 import와 export를 통해 모듈을 쉽게 정의하고 사용할 수 있습니다.

### ✅ 자바스크립트의 가비지 컬렉션에 대해 알고 있나요?

가비지 컬렉션은 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제하여 메모리 누수를 방지하는 프로세스입니다. 자바스크립트는 주로 마크 앤 스위프(Mark and Sweep) 알고리즘을 사용하여 가비지 컬렉션을 수행합니다.
