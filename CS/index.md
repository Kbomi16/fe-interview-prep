### ✅ CORS가 뭔가요?

- CORS (Cross-Origin Resource Sharing)는 웹 브라우저가 다른 출처의 리소스에 대한 요청을 허용하거나 차단하는 메커니즘입니다.
- 보안상의 이유로, 브라우저는 기본적으로 같은 출처의 리소스만 접근할 수 있도록 제한하지만, CORS를 통해 서버가 특정 출처의 요청을 허용할 수 있도록 설정할 수 있습니다.
- CORS는 서버가 HTTP 헤더를 통해 클라이언트에게 어떤 출처의 요청을 허용할지를 명시하며, 이는 웹 애플리케이션의 유연성과 상호운용성을 향상시킵니다.

### ✅CORS를 겪고 직접 해결해 본 경험이 있으면 말해주세요

[🍪보리의 FE 개발 노트](https://bori-note.tistory.com/19)

### ✅ 브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?

[🍪보리의 FE 개발 노트](https://bori-note.tistory.com/9)

1. DNS 조회:
   사용자가 브라우저에 "www.google.com"을 입력하면, 브라우저는 해당 도메인의 IP 주소를 알아내기 위해 DNS(Domain Name System)에 쿼리를 보냅니다.
2. DNS 서버 검색:
   브라우저는 운영체제에 등록된 DNS 서버에 DNS 쿼리를 전송합니다. 이 DNS 서버는 도메인에 해당하는 IP 주소를 반환합니다.
3. IP 주소 획득:
   DNS 서버가 www.google.com의 IP 주소를 찾으면 해당 IP 주소를 브라우저에게 전달합니다.
4. 서버 연결:
   브라우저는 획득한 IP 주소를 사용하여 웹 서버에 TCP/IP 연결을 시도합니다.
5. HTTP 요청:
   브라우저는 웹 서버에게 HTTP GET 요청을 보냅니다. 이 요청에는 브라우저의 사용자 에이전트 정보와 다양한 헤더가 포함될 수 있습니다.
6. 서버 응답:
   웹 서버는 브라우저의 요청에 대한 응답으로 HTML 문서와 함께 다양한 리소스(이미지, 스크립트 등)를 반환합니다.
7. 페이지 렌더링:
   브라우저는 받아온 HTML, CSS, JavaScript 등의 리소스를 해석하여 웹 페이지를 렌더링하고 화면에 표시합니다.

### ✅ DNS에 대해 설명해주세요.

DNS(Domain Name System)은 인터넷에서 도메인 이름을 IP 주소로 변환하거나, IP 주소를 도메인 이름으로 변환하는 역할을 하는 시스템입니다. 이는 사용자가 기억하기 쉬운 도메인 이름을 사용하여 웹사이트에 접속할 수 있도록 도와주며, 컴퓨터 네트워크 상에서 호스트의 위치를 찾는 데 사용됩니다.

- 도메인 이름 해석:
  사용자가 웹 브라우저에 도메인 이름(예: www.example.com)을 입력하면, DNS는 이를 해당 도메인의 IP 주소로 변환합니다.
- IP 주소를 도메인 이름으로 변환:
  네트워크 통신 시, IP 주소를 사용하여 특정 호스트에 연결해야 할 때, DNS는 이 IP 주소를 해당 호스트의 도메인 이름으로 변환합니다.
- 계층적인 구조:
  DNS는 계층적인 구조로 이루어져 있습니다. 최상위 도메인(Top-Level Domain, TLD)에서부터 하위 도메인, 호스트명까지 이어지는 구조로 도메인이 구성됩니다.
- 도메인 네임 서버:
  DNS는 전 세계에 분산된 도메인 네임 서버를 통해 동작합니다. 각 네임 서버는 특정 도메인에 대한 정보를 관리하고 해당 도메인의 IP 주소를 제공합니다.
- 캐싱:
  DNS는 캐싱을 통해 이전에 해석된 도메인 이름과 IP 주소의 매핑 정보를 일정 기간 동안 저장하여, 동일한 요청에 대한 응답 시간을 단축합니다.
  DNS는 인터넷에서 핵심적인 역할을 수행하며, 사용자가 도메인 이름을 통해 자원에 쉽게 액세스할 수 있도록 도와줍니다.

### ✅ GET과 POST의 차이는 무엇인가요?

GET:

- 정보를 서버로 전송하기 위해 사용되는 HTTP 메서드입니다.
- 주로 데이터를 요청할 때 사용하며, URL의 쿼리 매개변수로 데이터를 전달합니다.
- 데이터가 URL에 노출되기 때문에 보안에 취약할 수 있습니다.
- 브라우저에서 캐싱될 수 있으며, 브라우저 히스토리에 저장됩니다.
- 길이 제한이 있기 때문에 큰 데이터 전송에는 적합하지 않습니다.

POST:

- 서버로 데이터를 제출하기 위해 사용되는 HTTP 메서드입니다.
- 주로 로그인, 회원가입과 같은 데이터를 전송할 때 사용하며, 요청 본문에 데이터를 담아 전송합니다.
- 데이터가 URL에 노출되지 않아 GET보다 보안적으로 우수합니다.
- 브라우저에서 캐싱되지 않으며, 브라우저 히스토리에 남지 않습니다.
- 길이 제한이 없어 대용량 데이터 전송에 적합합니다.

### ✅ REST API에 대해 설명해주세요.

REST(Representational State Transfer)는 웹 상의 자원을 HTTP 프로토콜을 통해 전달하는 아키텍처 스타일입니다. REST API는 다음과 같은 특징을 갖춥니다:

- 자원(Resource):
  모든 것을 자원으로 표현하며, 각 자원은 고유한 식별자(URI)를 갖습니다.
- 표현(Representation):
  자원의 상태를 표현하는 방법으로 JSON, XML 등의 포맷을 사용합니다.
- 상태(Stateless):
  각 요청 간에 클라이언트의 상태를 서버에 저장하지 않고, 요청이 독립적으로 처리됩니다.
- 통일된 인터페이스(Uniform Interface):
  자원에 대한 표현과 행위(조회, 생성, 수정, 삭제)를 통일된 인터페이스로 수행합니다.
- 계층 구조(Layered System):
  시스템을 계층적으로 구성하여 각 계층이 독립적으로 동작하게 합니다.

  REST API는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 자원을 조작하고, URI를 통해 자원을 식별합니다.

### ✅ 객체 지향 프로그래밍이란 무엇인가요?

객체 지향 프로그래밍(OOP, Object-Oriented Programming)은 소프트웨어 개발 패러다임 중 하나로, 프로그램을 여러 개의 독립적인 단위인 "객체"들의 모임으로 보고, 이들 객체들을 상호작용하도록 설계하는 것입니다. 객체는 데이터와 데이터를 처리하는 메서드(함수)를 함께 묶어서 표현합니다.

- 캡슐화(Encapsulation):
  데이터와 그를 처리하는 메서드를 하나로 묶어 객체를 형성하며, 외부에서의 직접적인 접근을 제한합니다.
- 상속(Inheritance):
  이미 정의된 클래스의 속성과 메서드를 다른 클래스가 그대로 상속받아 사용할 수 있도록 합니다.
- 다형성(Polymorphism):
  같은 이름의 메서드나 연산자를 다양한 형태로 동작하도록 하는 기능입니다. 오버로딩(Overloading)과 오버라이딩(Overriding)을 포함합니다.
- 추상화(Abstraction):
  복잡한 현실 세계를 단순화하여 필요한 부분만 표현하고, 불필요한 부분은 숨기는 개념입니다.
  객체 지향 프로그래밍은 코드의 재사용성과 유지보수성을 높이고, 현실 세계의 모델을 소프트웨어로 구현하기에 적합한 패러다임입니다.

## 🔥 HTTP

### ✅ HTTP란 뭔가요?

- **HTTP (HyperText Transfer Protocol)**는 웹에서 데이터를 전송하기 위한 프로토콜입니다. 클라이언트와 서버 간의 요청 및 응답을 정의하며, 웹 페이지, 이미지, 비디오 등 다양한 리소스를 전송하는 데 사용됩니다.

### ✅ HTTP 프로토콜의 가장 큰 특징은 뭔가요?

- **무상태 (Stateless)**: HTTP는 각 요청이 독립적으로 처리되며, 이전 요청의 상태를 유지하지 않습니다. 이로 인해 서버는 요청 간에 정보를 저장할 필요가 없어 리소스 효율성이 높습니다.

### ✅ URL은 뭔가요?

- **URL (Uniform Resource Locator)**은 인터넷 상의 특정 리소스를 찾기 위한 주소입니다. 일반적으로 프로토콜 (예: HTTP), 호스트 (예: www.example.com), 경로 (예: /path/to/resource)로 구성됩니다.

### ✅ HTTP/1.0과 HTTP/1.1의 차이는 뭔가요?

- **HTTP/1.0**:
  - 요청 후 연결을 종료합니다 (non-persistent).
  - 요청 헤더에 Host 필드가 없습니다.
- **HTTP/1.1**:
  - 지속 연결을 지원하여, 하나의 TCP 연결로 여러 요청을 처리할 수 있습니다 (persistent).
  - Host 필드를 필수로 포함하여 가상 호스팅을 지원합니다.
  - 여러 추가 기능 (압축, 캐시 제어 등)을 제공합니다.

### ✅ HTTP/1.1과 HTTP/2.0의 차이는 뭔가요?

- **HTTP/2.0**:
  - 이진 프로토콜로, 더 효율적인 데이터 전송을 제공합니다.
  - Multiplexing을 지원하여 여러 요청을 동시에 처리할 수 있습니다.
  - 헤더 압축을 통해 데이터 전송을 최적화합니다.
  - 서버 푸시 기능을 통해 클라이언트가 요청하지 않은 리소스도 전송할 수 있습니다.

### ✅ HTTPS는 HTTP랑 뭐가 다른가요?

- **HTTPS (HyperText Transfer Protocol Secure)**는 HTTP에 보안 기능을 추가한 프로토콜입니다. SSL/TLS 암호화를 사용하여 데이터 전송 중 정보의 무결성과 기밀성을 보장합니다. 이를 통해 중간자 공격이나 데이터 유출을 방지할 수 있습니다.

### ✅ 심화) 공개키 (비대칭키) 방식이 뭔가요?

- **공개키 (비대칭키) 방식**은 암호화 방식의 하나로, 두 개의 키를 사용합니다: 공개키와 개인키.
  - **공개키**: 누구에게나 공개할 수 있는 키로, 데이터를 암호화하는 데 사용됩니다.
  - **개인키**: 소유자만 알고 있는 키로, 암호화된 데이터를 복호화하는 데 사용됩니다.

이 방식의 장점은 공개키로 암호화된 데이터는 오직 대응하는 개인키로만 복호화할 수 있다는 것입니다. 이를 통해 보안 통신을 가능하게 합니다.

## 🔥 싱글 스레드와 멀티 스레드

### ✅ 싱글 스레드의 장점

- 간단한 구조: 코드가 단순하여 이해하기 쉽고 디버깅이 용이함.
- 상태 관리 용이: 여러 스레드 간의 상태 공유 문제를 피할 수 있어 데이터 일관성을 유지하기 쉬움.
- 컨텍스트 스위칭 없음: 스레드 간 전환이 없기 때문에 오버헤드가 적음.

### ✅ 싱글 스레드의 단점

- 성능 저하: CPU 코어를 최대한 활용하지 못해 성능이 제한됨.
- 블로킹 작업: I/O 작업이나 긴 연산 시 전체 애플리케이션이 멈출 수 있음.
- 확장성 부족: 트래픽이 증가할 경우 처리 능력이 제한되어 병목 현상이 발생할 수 있음.

### ✅ 멀티 스레드의 장점

- 성능 향상: 여러 코어를 활용하여 작업을 병렬로 처리함으로써 성능이 향상됨.
- 비동기 처리: I/O 작업을 비동기적으로 처리하여 애플리케이션의 응답성을 높임.
- 자원 활용도 증가: CPU 자원을 더 효율적으로 활용할 수 있음.

### ✅ 멀티 스레드의 단점

- 복잡한 코드: 동기화, 상태 관리 등이 복잡해져 코드가 난해해질 수 있음.
- 디버깅 어려움: 스레드 간의 충돌이나 경합 조건으로 인해 디버깅이 어려워질 수 있음.
- 자원 경쟁: 여러 스레드가 자원을 동시에 접근할 때 충돌이 발생할 수 있어 성능 저하가 발생할 수 있음.

## 🔥 쿠키 + 세션

### ✅ 쿠키, 세션을 왜 쓰나요?

- **상태 유지**: 사용자 정보를 저장하여 상태를 유지하고, 웹 애플리케이션의 경험을 개선하기 위해 사용됩니다.
- **개인화**: 사용자 맞춤형 콘텐츠를 제공하거나 로그인 상태를 관리하는 데 유용합니다.

### ✅ 쿠키가 뭔가요?

- 쿠키는 사용자의 브라우저에 저장되는 작은 데이터 조각으로, 웹 서버가 클라이언트에게 정보를 저장하도록 허용합니다.
- 일반적으로 사용자 식별, 로그인 정보, 사용자 선호 설정 등을 저장하는 데 사용됩니다.

### ✅ 세션이 뭔가요?

- 세션은 서버 측에서 사용자와의 상호작용을 추적하기 위한 방법입니다.
- 세션 ID를 사용하여 사용자를 식별하고, 사용자 데이터를 서버에 저장하여 관리합니다.

### ✅ 쿠키와 세션의 차이는 어떤 점이 있을까요?

- **저장 위치**: 쿠키는 클라이언트(브라우저)에 저장되고, 세션은 서버에 저장됩니다.
- **유효 기간**: 쿠키는 설정된 만료 시간에 따라 지속되며, 세션은 사용자가 브라우저를 닫을 때 만료됩니다.
- **용량**: 쿠키는 일반적으로 4KB 이하의 데이터를 저장할 수 있으며, 세션은 서버 용량에 따라 더 많은 데이터를 저장할 수 있습니다.

### 💡 쿠키, 세션 웹스토리지의 차이

| 특성      | 쿠키                            | 세션                            | 웹스토리지                                          |
| --------- | ------------------------------- | ------------------------------- | --------------------------------------------------- |
| 저장 위치 | 브라우저에 저장                 | 서버에 저장                     | 브라우저에 저장                                     |
| 저장 용량 | 일반적으로 4KB 이하             | 서버에 따라 다름                | 일반적으로 각 도메인당 5MB 이상                     |
| 유효 기간 | 만료 날짜 설정 가능             | 브라우저가 열려 있는 동안 유효  | 브라우저가 닫힐 때까지 유효 (localStorage는 영구적) |
| 접근 방법 | HTTP 요청 시 자동 전송          | 서버 측에서 관리                | 자바스크립트를 통해 접근 가능                       |
| 보안      | XSS, CSRF 공격에 취약           | 세션 하이재킹 공격에 취약       | XSS 공격에 취약                                     |
| 사용 예   | 사용자 로그인 정보, 사이트 설정 | 장바구니 정보, 사용자 세션 관리 | 사용자 설정, 캐싱 데이터                            |

### ✅ 브라우저에서 탭 이동 혹은 탭 종료 시에는 세션 스토리지에 어떤 영향을 끼치나요?

- 브라우저 탭 간에는 별도의 세션 스토리지를 갖습니다.
  한 탭에서 세션 스토리지에 데이터를 저장하더라도, 다른 탭에서는 해당 데이터에 접근할 수 없습니다.
- 탭을 종료하면 해당 탭에서 사용한 세션 스토리지의 데이터는 모두 삭제됩니다.

### ✅ 로그인 처리를 할 때 쿠키와 세션을 어떻게 사용하시나요?

쿠키와 세션 활용:

- 사용자가 로그인하면 서버에서는 세션을 생성하고, 세션에 대한 식별자를 클라이언트에게 쿠키로 전송합니다.
- 이후 클라이언트의 모든 요청에는 해당 쿠키가 함께 전송되고, 서버는 쿠키를 통해 세션을 식별하여 사용자를 인증합니다.
- 세션은 서버 측에서 안전하게 관리되므로, 클라이언트는 세션 정보에 직접 접근할 수 없습니다.

### ✅ 토큰 기반 인증 방식에 대해 설명해주세요.

[🍪보리의 FE 개발 노트](https://bori-note.tistory.com/23)

- 사용자가 로그인하면 서버에서 토큰을 발급하고, 이 토큰을 클라이언트에게 전송합니다.
- 클라이언트는 이 토큰을 저장하고, 인증이 필요한 요청 시에 토큰을 함께 서버에 전송합니다.
- 서버는 전송받은 토큰을 검증하고, 토큰이 유효하면 해당 사용자를 인증합니다.
- 토큰은 일반적으로 JWT(JSON Web Token) 형식을 사용합니다.

### ✅ 인증과 인가에 대해 설명해주세요.

- **인증 (Authentication)**: 사용자가 자신이 주장하는 신원을 증명하는 과정입니다. 주로 사용자 이름과 비밀번호를 입력하거나, 생체 인식, OTP(일회용 비밀번호) 등을 통해 사용자의 신원을 확인합니다. 인증은 "당신은 누구인가?"라는 질문에 대한 답변을 제공합니다.

- **인가 (Authorization)**: 인증된 사용자가 특정 리소스나 작업에 접근할 수 있는 권한을 부여하는 과정입니다. 예를 들어, 사용자가 로그인을 한 후, 그 사용자가 특정 파일에 접근하거나, 특정 기능을 사용할 수 있는지 결정하는 것이 인가입니다. 인가는 "당신은 무엇을 할 수 있는가?"라는 질문에 대한 답변을 제공합니다.

### ✅ JWT을 아나요?

- JWT( JSON Web Token)는 JSON 객체를 사용하여 정보의 안전한 전송을 위한 토큰 기반 인증 방식입니다. 이 정보는 서명되어 변조되지 않도록 보호됩니다.

### ✅ JWT를 웹 스토리지에 저장해야 한다면 어디다 저장하시겠나요? 이유는요?

- **로컬 스토리지**에 저장하는 것이 좋습니다. 이유는:
- **세션 지속성**: 로컬 스토리지는 브라우저를 닫아도 데이터가 유지되어, 사용자가 다시 방문할 때 인증 상태를 유지할 수 있습니다.
- **보안 고려사항**: JWT는 CSRF 공격에 대한 보호가 필요하기 때문에, 다른 방법으로 보안을 강화하는 것이 좋습니다.

### ✅ JWT 토큰을 쿠키에 저장했을 때 취약점에 대해 설명해주세요.

XSS (Cross-Site Scripting) 공격:

- 악의적인 스크립트가 실행되어 쿠키에 접근하고 토큰을 탈취할 수 있습니다.
- 쿠키에는 HttpOnly 속성을 추가하여 JavaScript에서 접근할 수 없게 만들 수 있습니다.

CSRF (Cross-Site Request Forgery) 공격:

- 사용자의 의도와 무관하게 특정 요청을 전송하는 공격입니다.
  서버에서는 적절한 방어 메커니즘을 구현하여 특정 동작에 대한 사용자의 승인을 요구할 수 있습니다.

토큰 만료 관리:

- 토큰의 만료 시간을 적절히 설정하여 만료된 토큰을 사용하는 시도를 방지할 수 있습니다.

## 🔥 테스트

### ✅ 테스트란 무엇인가요?

- **테스트**는 소프트웨어의 품질을 보장하기 위해 코드의 기능과 성능을 평가하는 과정입니다. 이는 버그를 발견하고, 요구 사항을 충족하는지를 확인하는 데 중요한 역할을 합니다.

### ✅ 테스트의 예는 어떤 것들이 있나요?

- **유닛 테스트**: 개별 함수나 모듈을 테스트하여 예상한 대로 동작하는지 확인합니다.
- **통합 테스트**: 여러 모듈이나 컴포넌트가 함께 작동하는지 테스트합니다.
- **E2E (End-to-End) 테스트**: 전체 애플리케이션의 흐름을 테스트하여 사용자 시나리오가 올바르게 작동하는지를 검증합니다.
- **성능 테스트**: 시스템의 성능, 안정성, 응답 시간을 평가합니다.
- **회귀 테스트**: 기존 기능이 새로운 코드 변경 후에도 정상적으로 작동하는지를 확인합니다.

### ✅ 테스트는 왜 해야 하나요?

- **버그 발견**: 조기에 버그를 발견하여 수정 비용을 줄입니다.
- **품질 보장**: 소프트웨어의 품질과 신뢰성을 높입니다.
- **유지 보수 용이**: 코드 변경 시 기존 기능이 정상 작동하는지를 검증하여 유지 보수를 용이하게 합니다.
- **요구 사항 충족**: 개발된 소프트웨어가 사용자 요구 사항을 충족하는지를 확인합니다.

### ✅ 유닛 테스트란 무엇인가요?

- **유닛 테스트**는 소프트웨어의 가장 작은 단위인 함수나 메서드를 독립적으로 테스트하는 과정입니다. 각 유닛이 예상대로 작동하는지를 검증하며, 일반적으로 자동화된 도구를 사용하여 수행됩니다.

### ✅ 통합 테스트란 무엇인가요?

- **통합 테스트**는 여러 유닛이 함께 작동할 때의 상호작용을 검증하는 과정입니다. 개별 유닛이 잘 작동하더라도, 통합되었을 때 문제를 발생할 수 있으므로 이를 확인합니다.

### ✅ E2E 테스트란 무엇인가요?

- **E2E 테스트 (End-to-End 테스트)**는 사용자 관점에서 애플리케이션의 모든 기능이 올바르게 작동하는지를 검증하는 과정입니다. 실제 사용자의 행동을 시뮬레이션하여, 전체 시스템이 예상대로 동작하는지를 평가합니다.

## 🔥운영체제

### ✅ 운영체제란 무엇인가요?

운영체제(OS, Operating System)는 컴퓨터 시스템의 하드웨어와 소프트웨어 자원을 관리하고, 사용자와 컴퓨터 간의 상호작용을 원활하게 해주는 시스템 소프트웨어입니다. 컴퓨터 하드웨어를 직접 다루기보다는 운영체제를 통해 관리하게 됩니다.

### ✅ 운영체제는 어떤 역할을 하나요?

운영체제는 다음과 같은 주요 역할을 합니다:

- **프로세스 관리**: CPU 자원을 여러 프로그램에 효율적으로 분배.
- **메모리 관리**: 프로그램이 실행될 때 필요한 메모리 자원을 할당하고 해제.
- **파일 시스템 관리**: 데이터를 파일로 저장하고, 디렉터리 및 파일에 대한 접근을 제어.
- **입출력 장치 관리**: 키보드, 마우스, 프린터, 모니터 등 하드웨어 장치와 프로그램 간의 통신을 관리.
- **사용자 인터페이스 제공**: GUI 또는 CLI를 통해 사용자가 시스템을 쉽게 제어할 수 있도록 지원.

### ✅ 운영체제는 어떤 구조로 이루어져 있나요?

운영체제는 일반적으로 다음과 같은 계층적 구조를 가집니다:

1. **커널(Kernel)**: 운영체제의 핵심 부분으로, 하드웨어와 직접 상호작용하며 자원 관리를 담당.
2. **쉘(Shell)**: 사용자와 커널 간의 인터페이스로 명령어를 입력받아 처리.
3. **유틸리티(Utility)**: 다양한 시스템 관리 도구를 제공.
4. **드라이버(Driver)**: 하드웨어와 소프트웨어를 연결하는 역할을 하며, 장치와의 통신을 처리.

### ✅ 컴퓨터는 어떤 요소로 이루어져 있나요?

컴퓨터는 기본적으로 다음과 같은 주요 요소로 이루어져 있습니다:

- **CPU(중앙처리장치)**: 컴퓨터의 두뇌로서 명령을 처리하고 계산을 수행.
- **메모리**: 프로그램과 데이터를 저장하고, CPU가 이를 처리하는 데 필요한 자원을 제공.
- **입출력 장치**: 키보드, 마우스, 모니터, 프린터 등 사용자와 컴퓨터 간의 상호작용을 돕는 장치.
- **저장 장치**: 하드 드라이브(SSD, HDD)나 외부 저장 장치를 통해 데이터를 영구적으로 저장.

### ✅ CPU는 어떤 요소로 이루어져 있나요?

CPU는 다음과 같은 세 가지 주요 요소로 구성됩니다:

1. **연산 장치(ALU)**: 산술 연산과 논리 연산을 처리하는 부분.
2. **제어 장치(CU)**: 프로그램 명령을 해석하고 명령 실행 순서를 제어.
3. **레지스터(Register)**: 데이터를 일시적으로 저장하고 CPU 내의 계산과 명령 처리를 빠르게 하기 위한 소규모 저장 공간.

### ✅ CPU는 어떻게 동작하나요?

CPU는 다음과 같은 **명령 실행 사이클(Fetch-Decode-Execute)**에 따라 동작합니다:

1. **Fetch(가져오기)**: 메모리에서 명령어를 가져옵니다.
2. **Decode(해석하기)**: 가져온 명령어를 해석하여 어떤 작업을 수행해야 하는지 알아냅니다.
3. **Execute(실행하기)**: 해석된 명령을 실제로 수행하여 결과를 얻습니다.

### ✅ 메모리란 무엇인가요?

메모리는 프로그램이 실행되는 동안 데이터를 저장하고, CPU가 필요한 정보를 빠르게 접근할 수 있도록 하는 저장 공간입니다. **RAM**(주기억장치)과 **ROM**(보조기억장치)로 나뉩니다.

### ✅ 메모리는 어떤 계층 구조로 이루어져 있나요?

메모리는 다음과 같은 계층 구조로 이루어져 있습니다:

1. **레지스터**: CPU 내부에 위치한 초고속 메모리.
2. **캐시(Cache)**: CPU와 메인 메모리 사이에 위치하여 데이터 접근 속도를 높여주는 임시 저장 공간.
3. **주기억장치(Main Memory)**: RAM과 같은 메모리로 프로그램과 데이터를 저장.
4. **보조기억장치(Secondary Storage)**: 하드 드라이브, SSD 등 데이터를 영구적으로 저장하는 장치.

### ✅ 메모리는 어떤 방식으로 데이터를 관리하나요?

메모리는 **가상 메모리** 기법을 통해 실제 물리적 메모리보다 더 많은 데이터를 처리할 수 있도록 합니다. 메모리 관리자는 메모리 할당 및 해제를 제어하고, **페이지 교체 알고리즘**을 사용하여 필요한 데이터를 물리적 메모리에 효율적으로 배치합니다.

## 🔥 디자인 패턴

### ✅ 디자인 패턴의 종류(MVC / MVVM)

#### 💡 디자인 패턴이란?

어떤 것을 개발할 때 발생했던 문제점들을 정리해서 좀 더 쉽고 편리하게 개발할 수 있도록 만든 특정한 방법들을 의미한다. 디자인 패턴을 사용하면 유지보수가 편하다.

#### 💡 3-1. MVC Pattern

#### 📦 Model-View-Controller

- 대표적인 디자인 패턴으로 개발할 때 구성요소를 Model, View, Controller로 역할을 나누어 개발을 하는 것을 의미한다.
- 사용자가 Controller를 조작하면 Controller는 Model을 통해 데이터를 가져오고 해당 데이터를 View에게 뿌려준다.

#### 📦 동작 순서

1. 사용자가 웹사이트에 접속한다. (URL을 통한 웹서버 요청을 보냄)
2. 웹 서버의 요청을 받은 컨테이너가 URL과 매핑된 Controller를 찾는다.
3. Controller는 사용자가 요청한 웹 페이지를 서비스 하기 위해서 Model을 호출한다.
4. Model은 DB나 파일 등에 접근하거나 필요한 작업을 수행 후 결과를 리턴한다.
5. Controller는 Model이 리턴한 결과를 View에 반영한다.
6. 컨테이너와 웹서버를 거쳐 데이터가 반영된 View가 사용자에게 보여진다.

#### 📦 MVC 패턴을 사용하는 프레임워크/라이브러리

- Angular JS
- DJango
- React 등...

#### 💡3-2. MVVM Pattern

#### 📦 Model - View - View Model

- Model : 어플리케이션에 사용되는 데이터와 데이터를 처리
- View : 사용자에게 보여지는 UI
  View
- Model : View를 표현하기 위해 만든 View를 위한 Model. View를 나타내기 위한 데이터를 처리

#### 📦 동작 순서

1. 사용자의 Action이 VIew를 통해 들어온다.
2. Command 패턴을 이용하여 View Model에 Action을 전달한다.
3. View Model이 Model에서 데이터를 요청하고 Model은 View Model에서 요청받은 데이터를 전달한다.
4. View Model은 응답받은 데이터를 가공하고 저장한다.
5. View는 VIew Model과의 Data Binding을 이용해 화면을 갱신한다.

장점

- View와 Model 사이의 의존성이 없다.
- View와 View Model 사이의 의존성이 없다.
- 각 부분들이 독립적이므로 개별적 개발이 가능하다.

단점

- 어렵다.

#### 💡 Model, View, Controller의 차이

#### 📦 4-1. Model

비즈니스 영역의 로직을 처리한다.

규칙

- 사용자가 원하는 모든 데이터를 가지고 있는다
- 사용자가 원하는 모든 데이터를 가지고 있는다

#### 📦 4-2. View

- 데이터를 화면에 보여주는 부분. 사용자가 보게 될 결과화면.

규칙

- Model이 가지고 있는 정보를 따로 저장해서는 안 된다.
- Model이나 Controller와 같은 다른 구성요소들을 알아서는 안 된다.

#### 📦 4-3.Controller

View와 Controller를 조작. 사용자의 입력 처리와 흐름 제어를 담당한다.

규칙

- Model과 View에 대해서 알고 있어야 한다
- Model이나 View의 변경을 모니터링 해야 한다

### ✅ Forward와 Redirect의 차이

JSP 환경에서 현재 작업중인 페이지에서 다른 페이지로 이동하는 두 가지 방식의 페이지 전환 기능이다.
내부적으로 가장 큰 특징은 객체의 재사용 여부로, Forward 방식은 요청객체를 재사용하고, Redirect는 재사용하지 않는다.

#### 📦 5-1. Forward

말 그대로 forward(건네주기)를 한다. 다음 이동할 URL로 요청정보를 그대로 전달한다.
URL이 변하지 않는다.
현재 실행중인 페이지와 forward에 의해 호출된 페이지는 request와 response 객체를 공유한다.

```java
RequestDispatcher requestDispatcher = request.getRequestDispatcher("/newPage");
requestDispatcher.forward(request, response); //객체를 그대로 전달
```

#### 📦 5-2. Redirect

- URL이 새로운 URL로 변한다.
- redirect를 통해 호출된 새로운 페이지에서는 request와 response 객체가 새롭게 생성된다.
- 서블릿이나 JSP는 redirect를 하기 위해 HttpServletResponse 클래스의 sendRedirect() 메서드를 사용한다.
  ` response.sendRedirect("newPage.jsp");`
